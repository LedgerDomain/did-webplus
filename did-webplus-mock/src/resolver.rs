use std::borrow::Cow;

use did_webplus::{DIDDocument, DIDDocumentMetadata, Error, RequestedDIDDocumentMetadata, DID};

/// Trait defining the DID Resolver data model.  The two mock implementations of this are
/// MockResolverFull (keeps a local MockVerifiedCache of all DIDs it has resolved) and
/// MockResolverThin (does not keep a local MockVerifiedCache, and instead outsources the
/// retrieval and verification of DID microledgers to a MockVDG).
pub trait Resolver {
    /// Fetch a contiguous sequence of DID documents for the given DID.  Note that the version_id
    /// range is inclusive on both ends; if version_id_begin_o is None, then it is treated as 0,
    /// and if version_id_end_o is None, then it is treated as u32::MAX.  This is what a "full" client
    /// would use to retrieve (and cache) the full DID microledger so that it can do its own local
    /// verification of DID documents and its own local DID resolution.  Depending on the implementation
    /// of this trait, this may or may not involve network operations.
    // TODO: Also return a timestamp generated by the VDR (TODO: Figure out how this timestamp
    // works with a VDG).
    fn get_did_documents<'s>(
        &'s mut self,
        did: &DID,
        version_id_begin_o: Option<u32>,
        version_id_end_o: Option<u32>,
    ) -> Result<Box<dyn std::iter::Iterator<Item = Cow<'s, DIDDocument>> + 's>, Error>;
    /// This resolves the given DID, returning the DID document and its metadata.  The metadata
    /// is needed for determining the validity duration of a DID document so as to be able to
    /// determine if a signing key was active at a given time.  Only the metadata requested in
    /// the RequestedDIDDocumentMetadata struct will be returned.  Requesting less metadata may
    /// result in a faster resolution in some implementations of this trait, as some operations
    /// may be able to occur with fewer or no network operations, though the specifics depend
    /// on the implementation.
    // TODO: Also return a timestamp generated by the VDR (TODO: Figure out how this timestamp
    // works with a VDG).
    fn resolve_did_document<'s>(
        &'s mut self,
        did: &DID,
        self_hash_o: Option<&selfhash::KERIHash>,
        version_id_o: Option<u32>,
        requested_did_document_metadata: RequestedDIDDocumentMetadata,
    ) -> Result<(Cow<'s, DIDDocument>, DIDDocumentMetadata), Error>;
}
