use did_webplus_core::{
    DIDDocument, DIDDocumentMetadata, DIDStr, Error, RequestedDIDDocumentMetadata,
};
use std::borrow::Cow;

/// VDS = Verifiable Data Source (this is defined to be the common property that VDR and VDG both have).
/// This represents a service that is capable of servicing DID resolution requests.  The two kinds of
/// VDS are VDR and VDG.  Note that Resolver represents the client side of this interaction.
// TODO: If this is to be adopted as a trait in the did-webplus crate, then it should be VDS.
// TODO: These should use &self instead of &mut self
pub trait VDS {
    /// Fetch a contiguous sequence of DID documents for the given DID.  Note that the version_id
    /// range is inclusive on both ends; if version_id_begin_o is None, then it is treated as 0,
    /// and if version_id_end_o is None, then it is treated as u32::MAX.  This is what a "full" client
    /// would use to retrieve (and cache) the full DID microledger so that it can do its own local
    /// verification of DID documents and its own local DID resolution.  Depending on the implementation
    /// of this trait, this may or may not involve network operations.
    // TODO: Also return a timestamp generated by the VDR (TODO: Figure out how this timestamp
    // works with a VDG).
    fn get_did_documents<'s>(
        &'s mut self,
        requester_user_agent: &str,
        did: &DIDStr,
        version_id_begin_o: Option<u32>,
        version_id_end_o: Option<u32>,
    ) -> Result<Box<dyn std::iter::Iterator<Item = Cow<'s, DIDDocument>> + 's>, Error>;
    /// This resolves the given DID, returning the DID document and its metadata.  The metadata
    /// is needed for determining the validity duration of a DID document so as to be able to
    /// determine if a signing key was active at a given time.  Only the metadata requested in
    /// the RequestedDIDDocumentMetadata struct will be returned.  Requesting less metadata may
    /// result in a faster resolution in some implementations of this trait, as some operations
    /// may be able to occur with fewer or no network operations, though the specifics depend
    /// on the implementation.
    // TODO: Also return a timestamp generated by the VDR (TODO: Figure out how this timestamp
    // works with a VDG).
    fn resolve_did_document<'s>(
        &'s mut self,
        requester_user_agent: &str,
        did: &DIDStr,
        version_id_o: Option<u32>,
        self_hash_o: Option<&mbc::MBHashStr>,
        requested_did_document_metadata: RequestedDIDDocumentMetadata,
    ) -> Result<(Cow<'s, DIDDocument>, DIDDocumentMetadata), Error>;
}
