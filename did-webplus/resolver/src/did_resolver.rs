use crate::{Error, Result};

/// Note that a DIDResolver is a VerifierResolver for prefix "did:webplus:"
#[async_trait::async_trait]
pub trait DIDResolver: Send + Sync + verifier_resolver::VerifierResolver {
    /// This resolves the given DID, returning the DID document and its metadata.  The metadata
    /// is needed for determining the validity duration of a DID document so as to be able to
    /// determine if a signing key was active at a given time.  Only the metadata requested in
    /// the RequestedDIDDocumentMetadata struct will be returned.  Requesting less metadata may
    /// result in a faster resolution in some implementations of this trait, as some operations
    /// may be able to occur with fewer or no network operations, though the specifics depend
    /// on the implementation.
    // TODO: Also return a timestamp generated by the VDR (TODO: Figure out how this timestamp
    // works with a VDG).
    async fn resolve_did_document_string(
        &self,
        did_query: &str,
        requested_did_document_metadata: did_webplus_core::RequestedDIDDocumentMetadata,
    ) -> Result<(String, did_webplus_core::DIDDocumentMetadata)>;
    /// Convenience method.  This just calls into resolve_did_document_string and then deserializes
    /// the DID document string into a DIDDocument struct.
    async fn resolve_did_document(
        &self,
        did_query: &str,
        requested_did_document_metadata: did_webplus_core::RequestedDIDDocumentMetadata,
    ) -> Result<(
        did_webplus_core::DIDDocument,
        did_webplus_core::DIDDocumentMetadata,
    )> {
        let (did_document_string, did_document_metadata) = self
            .resolve_did_document_string(did_query, requested_did_document_metadata)
            .await?;
        let did_document: did_webplus_core::DIDDocument =
            serde_json::from_str(&did_document_string)
                .map_err(|e| Error::MalformedDIDDocument(e.to_string().into()))?;
        Ok((did_document, did_document_metadata))
    }
}

/// Implementations of DIDResolver can use this to provide the guts to the implementation
/// of verifier_resolver::VerifierResolver.
pub async fn verifier_resolver_impl(
    verifier_str: &str,
    did_resolver: &dyn DIDResolver,
) -> verifier_resolver::Result<Box<dyn selfsign::Verifier>> {
    if !verifier_str.starts_with("did:webplus:") {
        Err(verifier_resolver::Error::InvalidVerifier(
            format!(
                "expected verifier to begin with \"did:webplus:\", but verifier was {:?}",
                verifier_str
            )
            .into(),
        ))?;
    }

    tracing::debug!(
        "verifier was {:?}; verifying using did:webplus method",
        verifier_str
    );
    let did_key_resource_fully_qualified =
        did_webplus_core::DIDKeyResourceFullyQualifiedStr::new_ref(verifier_str).map_err(|_| verifier_resolver::Error::InvalidVerifier(format!("if did:webplus DID is used as verifier, it must be fully qualified, i.e. it must contain the selfHash and versionId query parameters and a fragment specifying the key ID, but it was {:?}", verifier_str).into()))?;

    let (_did_document, _did_doc_metadata) = did_resolver
        .resolve_did_document(
            did_key_resource_fully_qualified.without_fragment().as_str(),
            did_webplus_core::RequestedDIDDocumentMetadata::none(),
        )
        .await?;
    // Part of DID doc verification is ensuring that the key ID represents the same public key as
    // the JsonWebKey2020 value.  So we can use the key ID KERIVerifier value as the public key.
    // TODO: Assert that this is actually the case.

    Ok(Box::new(
        did_key_resource_fully_qualified.fragment().to_owned(),
    ))
}
